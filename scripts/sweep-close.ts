/**
 * Sweep-close leftover empty vaults (amount == 0) owned by your wallet
 * as creator/receiver/authority. Requires the program to include the
 * `close_vault` instruction added in this change and a fresh `anchor build`
 * so the IDL contains it.
 *
 * Usage:
 *   cd Time-locked-wallet
 *   anchor build && anchor deploy   # ensure program + IDL updated
 *   npm install @coral-xyz/anchor bs58
 *   npx ts-node scripts/sweep-close.ts
 */

import * as anchor from "@coral-xyz/anchor";
import bs58 from "bs58";

async function main() {
  // Use provider from Anchor.toml
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const walletPk = provider.publicKey!;

  // Load IDL generated by anchor build
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const idl = require("../target/idl/time_locked_wallet.json");
  const programId = new anchor.web3.PublicKey(idl.address);
  const program = new anchor.Program(idl, provider);

  const tagNone = bs58.encode(Buffer.from([0]));
  const tagSome = bs58.encode(Buffer.from([1]));
  const pkb58 = walletPk.toBase58();

  const conn = provider.connection;

  // Fetch vaults where you are creator
  const byCreator = await program.account.timeLock.all([
    { memcmp: { offset: 8, bytes: pkb58 } },
  ]);

  // Fetch vaults where you are receiver (authority None)
  const byReceiverNone = await program.account.timeLock.all([
    { memcmp: { offset: 8 + 32, bytes: tagNone } },
    { memcmp: { offset: 8 + 32 + 1, bytes: pkb58 } },
  ]);

  // Fetch vaults where you are receiver (authority Some)
  const byReceiverSome = await program.account.timeLock.all([
    { memcmp: { offset: 8 + 32, bytes: tagSome } },
    { memcmp: { offset: 8 + 32 + 1 + 32, bytes: pkb58 } },
  ]);

  // Merge and de-duplicate
  const map = new Map<string, any>();
  for (const v of [...byCreator, ...byReceiverNone, ...byReceiverSome]) {
    map.set(v.publicKey.toBase58(), v);
  }
  const all = Array.from(map.values());

  const candidates = all.filter((v) => Number(v.account.amount) === 0);
  if (candidates.length === 0) {
    console.log("No empty vaults found for", walletPk.toBase58());
    return;
  }

  console.log(`Found ${candidates.length} empty vault(s). Closing...`);

  // Close sequentially to avoid rate limits
  for (const v of candidates) {
    const vaultPk = v.publicKey as anchor.web3.PublicKey;
    const creatorPk = v.account.creator as anchor.web3.PublicKey;
    try {
      const sig = await program.methods
        .closeVault()
        .accounts({
          vault: vaultPk,
          creatorAccount: creatorPk,
          closer: walletPk,
        })
        .rpc();
      console.log("Closed:", vaultPk.toBase58(), sig);
      // Optionally confirm
      await conn.confirmTransaction(sig, "confirmed");
    } catch (e: any) {
      console.error("Failed to close", vaultPk.toBase58(), e?.message || e);
    }
  }

  console.log("Done.");
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});

